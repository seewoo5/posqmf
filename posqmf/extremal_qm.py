

# This file was *autogenerated* from the file ./posqmf/sage/extremal_qm.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_6 = Integer(6); _sage_const_720 = Integer(720); _sage_const_0 = Integer(0); _sage_const_7 = Integer(7); _sage_const_5 = Integer(5); _sage_const_12 = Integer(12); _sage_const_72 = Integer(72); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_4 = Integer(4); _sage_const_288 = Integer(288); _sage_const_36 = Integer(36); _sage_const_16 = Integer(16)# Use cache
import os
from functools import lru_cache

load(os.path.dirname(os.path.abspath(__file__)) + "/sage/utils_l1.sage")

# Extremal quasimodular forms
def is_extremal_qm(qm):
    # Check if a given quasimodular form is extremal (in the sense of Kaneko-Koike)
    s = qm_depth(qm)
    w = qm.weight()
    d = dim_qm(w, s)
    order = qm_cusp_order(qm)
    return d - _sage_const_1  == order
    
@lru_cache(maxsize=None)
def _extremal_qm_d1(w):
    if w < _sage_const_6 :
        assert False, "weight should be >= 6"
    if w == _sage_const_6 :
        return (_sage_const_1  / _sage_const_720 ) * (E2 * E4 - E6)
    else:
        if w % _sage_const_6  == _sage_const_0 :
            _qm = _extremal_qm_d1(w - _sage_const_6 )
            res = E4 * qm_serre_derivative(_qm, w - _sage_const_7 ) - ((w - _sage_const_5 ) / _sage_const_12 ) * E6 * _qm
            res *= w / (_sage_const_72  * (w - _sage_const_5 ) * (w - _sage_const_1 ))
            assert is_extremal_qm(res), "not extremal"
            return res
        elif w % _sage_const_6  == _sage_const_2 :
            _qm = _extremal_qm_d1(w - _sage_const_2 )
            res = (_sage_const_12  / (w - _sage_const_1 )) * qm_serre_derivative(_qm, w - _sage_const_3 )
            assert is_extremal_qm(res), "not extremal"
            return res
        elif w % _sage_const_6  == _sage_const_4 :
            _qm = _extremal_qm_d1(w - _sage_const_4 )
            res = E4 * _qm
            assert is_extremal_qm(res), "not extremal"
            return res
        else:
            assert False, "weight is odd"
    
@lru_cache(maxsize=None)
def _extremal_qm_d2(w):
    if w < _sage_const_4 :
        assert False, "weight should be >= 4"
    if w == _sage_const_4 :
        return (_sage_const_1  / _sage_const_288 ) * (E4 - E2**_sage_const_2 )
    elif w % _sage_const_4  == _sage_const_0 :
        _qm = _extremal_qm_d2(w - _sage_const_4 )
        res = ((w - _sage_const_3 ) * (w - _sage_const_4 ) / _sage_const_36 ) * E4 * _qm
        res -= qm_serre_derivative(qm_serre_derivative(_qm, w - _sage_const_6 ), w - _sage_const_4 )
        res *= (_sage_const_3  * (w)**_sage_const_2 ) / (_sage_const_16  * (w - _sage_const_1 ) * (w - _sage_const_2 )**_sage_const_2  * (w - _sage_const_3 ))
        assert is_extremal_qm(res), "not extremal"
        return res
    elif w % _sage_const_4  == _sage_const_2 :
        _qm = _extremal_qm_d2(w - _sage_const_2 )
        res = qm_serre_derivative(_qm, w - _sage_const_4 )
        res *= (_sage_const_6  / (w - _sage_const_1 ))
        assert is_extremal_qm(res), "not extremal"
        return res
    else:
        assert False, "weight is odd"

@lru_cache(maxsize=None)
def extremal_qm(weight, depth):
    # Find the extremal qmf (if exists) for given weight and depth
    # The result is normalized so that first nonzero coefficient is 1
    assert (_sage_const_0  <= depth <= weight/_sage_const_2  and _sage_const_2  * (depth + _sage_const_1 ) != weight), "inappropriate weight and depths"
    
    if depth == _sage_const_1 :
        return _extremal_qm_d1(weight)
    if depth == _sage_const_2 :
        return _extremal_qm_d2(weight)

    bs = qm_basis(weight, depth)
    d = dim_qm(weight, depth)
    m = matrix([qm_coefficients(qm_, d) for qm_ in bs])
    c_ = vector([_sage_const_0 ] * (d - _sage_const_1 ) + [_sage_const_1 ])
    x_ = m.solve_left(c_)
      
    ans = sum(x_[j] * bs[j] for j in range(d))
    return ans

